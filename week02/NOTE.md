学习笔记

## 堆排序

参照数据结构与算法之美，学习了一下堆排序



堆排序一共分为两个步骤

- 建堆
- 排序过程



建堆过程：从最后一个非叶子结点，每一个结点从上到下进行堆化，这样建好堆。

```java


private static void buildHeap(int[] a, int n) {
  for (int i = n/2; i >= 1; --i) {
    heapify(a, n, i);
  }
}

private static void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

建堆的时间复杂度为O(n),并不是O（nlogn）



排序过程：

每次先删除堆顶元素，再把最后一个元素放在堆顶中，重复此过程，就完成堆排序，时间复杂度为O(nlogn), 所以堆排序的总时间复杂度即为O(nlogn)。

![img](assets/23958f889ca48dbb8373f521708408d1.jpg)

## 本周刷题表

|                         | 1     | 2     | 3     | 4    | 5    |
| ----------------------- | ----- | ----- | ----- | ---- | ---- |
| Y 242. 有效的字母异位词 | 10.26 | 10.26 | 10.27 |      |      |
| Y 49. 字母异位词分组    | 10.26 | 10.26 | 10.27 |      |      |
| Y 94. 二叉树中序遍历    | 10.27 | 10.27 | 10.28 |      |      |
| Y 144. 二叉树前序遍历   | 10.27 | 10.27 | 10.28 |      |      |
| Y 145. 二叉树后序遍历   | 10.27 | 10.27 | 10.28 |      |      |
| Y 589. N叉树的前序遍历  | 10.28 | 10.28 |       |      |      |
| Y 590. N叉树的后序遍历  | 10.28 | 10.28 |       |      |      |
| Y 429. N叉树的层次遍历  | 10.28 | 10.28 |       |      |      |
| Y 1021.删除最外层的括号 | 10.28 | 10.28 |       |      |      |
| Y 剑指 40最小的K个数    | 11.1  | 11.1  |       |      |      |
| Y 264. 丑数             | 11.1  | 11.1  |       |      |      |
| Y 347. 前K个高频元素    | 11.1  | 11.1  |       |      |      |